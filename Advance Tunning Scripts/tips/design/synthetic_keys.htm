<html>
	<head>
		<title>
			Considering Synthetic Keys and Reverse Key Indexes
		</title>
		<style>
			<!-- a:hover{color:#660066;} -->
		</style>
	</head>
	<body background="../../images/bg.jpg" link="#FF6600" vlink="#FF6600" alink="#660066">
		
		<h2 align="center">
			<font color="#990000">
				Considering Synthetic Keys<br>
				and Reverse Key Indexes
			</font>
		</h2>
		<p>
		For most entities identified in a logical data model,
		there should be at least one set of attributes which constitute a natural candidate key.
		For example, a customer may be identified by their social security number,
		or an item of equipment may be identified by its serial number.
		</p>
		
		<h3>
			<font color="#660066">
				Why use synthetic keys?
			</font>
		</h3>
		<p>
		However, instead of such natural keys, a synthetic key (also called a surrogate key)
		of a single numeric column generated from a sequence number generator may well provide a better primary key.
		There are six factors to consider in making this decision:
		</p>
		<h4>
			<font color="#990000">
				Index Maintenance
			</font>
		</h4>
		<blockquote>
			<p>
			In general, it is necessary to index the natural key regardless of whether a synthetic primary key is used.
			So adding a synthetic key increases the index maintenance overhead for inserts and deletes.
			</p>
		</blockquote>
		<h4>
			<font color="#990000">
				Joins
			</font>
		</h4>
		<blockquote>
			<p>
			If a synthetic key is used, the natural key is not available in the child tables,
			and thus an extra join back to the parent table may be needed in some cases.
			</p>
		</blockquote>
		<h4>
			<font color="#990000">
				Index Size
			</font>
		</h4>
		<blockquote>
			<p>
			Because a synthetic key would be smaller, both the primary and foreign key indexes would be smaller, and quite possibly have shallower B*-trees.
			If so, joins using these indexes would be faster, as would fast full index scans.
			</p>
		</blockquote>
		<h4>
			<font color="#990000">
				Table Size
			</font>
		</h4>
		<blockquote>
			<p>
			Although the addition of a synthetic key may make a table slightly larger, and hence need more multiblock reads for a full table scan,
			the related tables containing the foreign key would be significantly smaller and would thus scan more efficiently.
			</p>
		</blockquote>
		<h4>
			<font color="#990000">
				Key Updates
			</font>
		</h4>
		<blockquote>
			<p>
			Natural key values do sometimes need to be updated, but synthetic keys do not.
			If a natural key is used as the primary key, then key updates will have to be cascaded.
			Apart from the extra work involved, for both the developers and the database engine,
			such cascading updates can dramatically reduce concurrency.
			</p>
		</blockquote>
		<h4>
			<font color="#990000">
				Disconnected Inserts
			</font>
		</h4>
		<blockquote>
			<p>
			To use a synthetic key in a distributed environment with disconnected nodes that need to insert records,
			each node needs to generate a mutually exclusive range of key values from its own sequence generator.
			The allocation of key ranges needs careful management, whereas there is no such consideration if a natural key is used.
			</p>
		</blockquote>
		<h4>
			<font color="#990000">
				Partitioning
			</font>
		</h4>
		<blockquote>
			<p>
			Using a synthetic key severely limits the available partitioning strategies.
			</p>
		</blockquote>
		<p>
		The net effect of these considerations is normally to use a synthetic key in preference to a natural key.
		
		<h3>
			<font color="#660066">
				Why use reverse key indexes?
			</font>
		</h3>
		<p>
		There is, however, a major scalability danger with automatically generated synthetic keys.
		Every insertion to a table requires a corresponding insertion to its primary key index.
		If the primary key values are being generated in ascending order, then all inserts will need to change the high-order leaf block in the B*-tree.
		There is an obvious danger here of contention for that block of the index, if several users attempt concurrent inserts.
		(Whereas the inserts to the table itself can easily be distributed to a variety of blocks by using multiple process freelists).
		</p>
		<p>
		Prior to Oracle8, the standard strategy to avoid this problem was to ensure that the synthetic key values were not generated in order.
		This was done by permuting the values generated by the sequence number generator before using them.
		Various permutation schemes such as adding a leading check digit, or reversing the order of the digits, have been used.
		These schemes have the effect of distributing inserts evenly over the range of values in the index, thus preventing leaf block contention.
		In Oracle8, the same effect may be obtained by using a reverse key index.
		</p>
		<p>
		The major disadvantage of distributing inserts in this way is that the data density of
		index leaf blocks will be typically only 75% of capacity rather than almost 100%,
		making fast full index scans on the primary key index less efficient.
		However, this access path is not typical and is seldom performance critical when used.
		So, reverse key indexes should be used in general for synthetic primary key indexes.
		</p>
		
		<hr noshade align="left" width="300" size="2" color="black">
		<table cellpadding="0" cellspacing="0">
			<tr>
				<td valign="top" width="1000">
					<font size="2" color="#660066">
						<strong>
							Copyright © Ixora Pty Ltd
						</strong>
					</font>
				</td>
				<td valign="top" align="right">
					<nobr>
					<map name="email">
						<area shape="rect" coords="0, 0, 32, 21" title="Feedback" href="mailto:feedback@ixora.com.au?SUBJECT=[Tip] synthetic_keys.htm">
					</map>
					<img ismap usemap="#email" border="0" alt="Send Email" src="../../images/email.gif" width="32" height="21">
					<map name="home">
						<area shape="rect" coords="0, 0, 28, 28" title="Home" href="/">
					</map>
					<img ismap usemap="#home" border="0" alt="Home" src="../../images/home.gif" width="28" height="28">
					</nobr>
				</td>
			</tr>
		</table>
	</body>
</html>
